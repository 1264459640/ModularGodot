
## 1. 架构设计

1. **技术实现**：

    - 基于R3库实现
    - 使用Autofac进行依赖注入
2. **核心接口**：


```csharp
// 事件标记接口
public interface IEvent {}

// 事件总线接口
public interface IEventBus
{
    void Publish<T>(T @event) where T : IEvent;
    IDisposable Subscribe<T>(Action<T> handler) where T : IEvent;
}


```

## 2. 事件定义规范


1. **事件存放位置**：

    -  `TO.Events`

2. **事件定义示例**：


```csharp
// UI隐藏事件
public record Hide : IEvent;

// 音量改变事件
public record VolumeChanged(AudioType Type, float Volume) : IEvent;


```

## 3. 使用模式

### 事件发布


```csharp
// 通过IIndex注入
private readonly IIndex<EventEnums, IEventBus> _eventBus;

// 发布UI事件
_eventBus.Publish(new Hide());

// 发布领域事件
_eventBus.Publish(new DomainEvent());


```

### 事件订阅


```csharp
// 在构造函数中订阅
public MyService(IIndex<EventEnums, IEventBus> eventBus)
{
    // 订阅UI事件
    var subscription = eventBus[EventEnums.UI]
        .Subscribe<Hide>(e => HandleHide());
    
}

private void HandleHide()
{
    // 处理隐藏逻辑
}


```

## 5. 实际案例

### NodeVolumeSettingsScreenService中的使用


```csharp
public class NodeVolumeSettingsScreenService : BaseService
{
    private readonly IIndex<EventEnums, IEventBus> _eventBus;

    public NodeVolumeSettingsScreenService(IIndex<EventEnums, IEventBus> eventBus)
    {
        _eventBus = eventBus;
    }

    private void OnBackButtonPressed()
    {
        // 发布UI隐藏事件
        _eventBus[EventEnums.UI].Publish(new Hide());
    }
}


```

## 6. 最佳实践


1. **事件设计**：

    - 保持事件轻量，只包含必要数据
    - 使用record类型定义不可变事件
2. **生命周期管理**：

    - 及时取消订阅避免内存泄漏
    - 使用BaseService的AddDisposable管理订阅
