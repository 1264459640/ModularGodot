# 示例代码与自动注册规范

## 📋 概述

本文档整理了项目中的示例代码和基于Autofac的自动注册规则，展示了如何在DDD架构下实现节点的依赖注入和生命周期管理。

## 📝 命名规范总结

### 表示层 (Scripts/Tests/Examples)
- **节点类**: `TestNode`, `TestManager`
- **接口**: `ITestNode`, `ITestManager`
- **特性**: 使用 `[GlobalClass]` 标记可在编辑器中使用的类

### 应用层 (TO.Apps.Services)
- **节点服务**: `NodeTestNodeService` (以 `Node` 开头)
- **普通服务**: `XxxService` (不以 `Node` 开头)
- **⚠️ 重要提示**: 非节点服务如果构造函数中需要执行逻辑代码，必须在 `TO.Contexts\Contexts.cs` 中手动解析该服务，否则构造函数逻辑不会被执行
- **🔴 节点服务层级限制**: 节点只有应用层服务，节点管理器才可以同时有领域层服务和应用层服务。如果在领域层创建节点服务将不会自动注册进容器

### 基础设施层 (TO.Infras.Repositories)
- **节点仓储**: `NodeTestNodeRepo` (对应节点服务)
- **单例仓储**: `TestManagerRepo` (对应单例管理器)
- **普通仓储**: `XxxRepo` (不以特殊前缀开头)

### 领域层接口 (TO.Domains.Models.Repositories.Abstractions)
- **节点仓储接口**: `INodeTestNodeRepo`
- **单例仓储接口**: `ITestManagerRepo`
- **节点接口**: `ITestNode`, `ITestManager`

## 🔧 自动注册规则

### NodeRegister - 单例节点注册器

**文件位置**: `TO.Domains.Models.Repositories.Abstractions\Nodes\NodeRegister.cs`

```csharp
using TO.Domains.Models.Repositories.Abstractions.Core.AudioSystem;
using TO.Domains.Models.Repositories.Abstractions.Core.SceneSystem;
using TO.Domains.Models.Repositories.Abstractions.Core.SerializationSystem;
using TO.Domains.Models.Repositories.Abstractions.Core.UISystem;
using TO.Domains.Models.Repositories.Abstractions.Test.Examples;
using TO.GodotNodes.Abstractions;
using TO.Nodes.Abstractions.Nodes.Singletons;
using TO.Nodes.Abstractions.Tests.Examples;

namespace TO.Domains.Models.Repositories.Abstractions.Nodes;

public class NodeRegister(
    ITestManagerRepo testManagerRepo,
    IUIManagerRepo uiManagerRepo, 
    IAudioManagerRepo audioManagerRepo, 
    ISaveManagerRepo saveManagerRepo,
    ISceneManagerRepo sceneManagerRepo)
{
    public bool Register<T>(T node) where T : INode
    {
        return node switch
        {
            // 单例管理器注册
            ITestManager testManager => testManagerRepo.Register(testManager),
            IUIManager uiManager => uiManagerRepo.Register(uiManager),
            IAudioManager audioManager => audioManagerRepo.Register(audioManager),
            ISaveManager saveManager => saveManagerRepo.Register(saveManager),
            ISceneManager sceneManager => sceneManagerRepo.Register(sceneManager),
            _ => throw new ArgumentException($"暂不支持的单例节点：{typeof(T).Name}")
        };
    }
}
```

**核心功能**:
- **统一注册入口**: 为所有单例管理器节点提供统一的注册接口
- **类型安全**: 通过泛型和模式匹配确保类型安全
- **依赖注入**: 通过构造函数注入所有需要的仓储接口
- **错误处理**: 对不支持的节点类型抛出明确的异常信息

**使用场景**:
- 当单例管理器节点（如 UIManager、AudioManager 等）需要注册到系统时
- 在 `Contexts.Instance.RegisterNode<T>()` 内部被调用
- 确保所有单例节点都能正确注册到对应的仓储中

**扩展步骤**:
1. 在构造函数中添加新的仓储接口参数
2. 在 `Register` 方法的 switch 表达式中添加新的 case 分支
3. 确保新的仓储接口和实现已在 DI 容器中注册

### NodeModule - 节点服务自动注册

**文件位置**: `TO.Contexts\NodeModule.cs`

```csharp
using System.Reflection;
using Autofac;
using Module = Autofac.Module;

namespace Contexts;

public class NodeModule: Module
{
    protected override void Load(ContainerBuilder builder)
    {
        var appServicesAssembly = Assembly.Load("TO.Apps.Services");
        var repoAssembly = Assembly.Load("TO.Infras.Repositories");
        var servicesTypes = appServicesAssembly.GetTypes()
            .Where(t => t.Name.StartsWith("Node"));

        foreach (var commandType in servicesTypes)
        {
            var repoTypeName = commandType.Name.Replace("Service", "Repo");
            var repoType = repoAssembly.GetTypes().FirstOrDefault(t => 
                t.Name == repoTypeName
            );
            if (repoType != null)
            {
                builder.RegisterType(commandType)
                    .AsSelf()
                    .InstancePerMatchingLifetimeScope(repoType);
            }
        }
    }
}
```

**注册规则**:
1. **命名约定**: 服务类名必须以 `Node` 开头
2. **配对规则**: `NodeXxxService` 对应 `NodeXxxRepo`
3. **生命周期**: 使用 `InstancePerMatchingLifetimeScope` 与对应仓储绑定
4. **程序集扫描**: 自动扫描 `TO.Apps.Services` 和 `TO.Infras.Repositories` 程序集
5. **🔴 层级限制**: 仅扫描应用层(`TO.Apps.Services`)中的节点服务，领域层中的节点服务不会被自动注册

### SingleModule - 单例服务自动注册

**文件位置**: `TO.Contexts\SingleModule.cs`

**注册规则**:
1. **应用服务**: 不以 `Node` 开头的类型
2. **领域服务**: 以 `Service` 结尾且不以 `Node` 开头的类型
3. **仓储服务**: 不以 `Node`、`Base`、`Singleton` 开头的类型
4. **接口匹配**: 自动匹配 `XxxService` 与 `IXxxService` 接口
5. **生命周期**: 所有服务注册为 `SingleInstance`
6. **⚠️ 构造函数逻辑**: 非节点服务如果构造函数包含业务逻辑，需要在 `Contexts.cs` 中手动解析以确保逻辑执行

## 🏗️ 架构层次示例

### 表示层 (Presentation Layer)

#### 普通节点示例 - TestNode

**文件位置**: `Scripts\Tests\Examples\TestNode.cs`

```csharp
using Autofac;
using Contexts;
using Godot;
using inFras.Tests.Examples;
using TO.Nodes.Abstractions.Tests.Examples;

namespace demo.Tests.Examples;

[GlobalClass]
public partial class TestNode : Node, ITestNode
{
    public ILifetimeScope? NodeScope { get; set; }
    
    public override void _Ready()
    {
        NodeScope = NodeContexts.Instance.RegisterNode<ITestNode, NodeTestNodeRepo>(this);
    }
}
```

**关键特性**:
- 继承自 `Node` 并实现 `ITestNode` 接口
- 使用 `[GlobalClass]` 特性标记
- 在 `_Ready()` 方法中注册节点到依赖注入容器
- 通过 `NodeContexts.Instance.RegisterNode` 进行注册

#### 单例管理器示例 - TestManager

**文件位置**: `Scripts\Tests\Examples\TestManager.cs`

```csharp
using Autofac;
using Godot;
using TO.Nodes.Abstractions.Tests.Examples;

namespace demo.Tests.Examples;

public partial class TestManager : Node, ITestManager
{
    public ILifetimeScope? NodeScope { get; set; }
    
    public override void _Ready()
    {
        Contexts.Contexts.Instance.RegisterNode<ITestManager>(this);
    }
}
```

**关键特性**:
- 单例管理器节点的实现模式
- 使用 `Contexts.Contexts.Instance.RegisterNode` 进行单例注册
- 不需要指定具体的仓储类型

### 应用层 (Application Layer)

#### 节点服务示例 - NodeTestNodeService

**文件位置**: `TO.Apps.Services\Tests\Examples\NodeTestNodeService.cs`

```csharp
using Godot;

namespace TO.Apps.Services.Tests.Examples;

public class NodeTestNodeService
{
    public NodeTestNodeService()
    {
        GD.Print("NodeTestNodeService: Initialized");
    }
}
```

**关键特性**:
- 类名以 `Node` 开头，符合自动注册规则
- 简单的服务实现，可在构造函数中进行初始化
- 会被 `NodeModule` 自动注册

### 基础设施层 (Infrastructure Layer)

#### 普通节点仓储示例 - NodeTestNodeRepo

**文件位置**: `TO.Infras.Repositories\Tests\Examples\NodeTestNodeRepo.cs`

```csharp
using inFras.Bases;
using TO.Domains.Models.Repositories.Abstractions.Test.Examples;
using TO.Events.Contexts;
using TO.Nodes.Abstractions.Tests.Examples;

namespace inFras.Tests.Examples;

public class NodeTestNodeRepo : NodeRepo<ITestNode>, INodeTestNodeRepo
{
    public NodeTestNodeRepo(ITestNode main)
    {
        Node = main;
        Register();
        ContextEvents.TriggerRegisterNode(this, ConfigureNodeScope);
    }
}
```

**关键特性**:
- 继承自 `NodeRepo<ITestNode>`
- 实现对应的仓储接口 `INodeTestNodeRepo`
- 构造函数接收节点实例并进行注册
- 触发上下文事件进行节点作用域配置

#### 单例节点仓储示例 - TestManagerRepo

**文件位置**: `TO.Infras.Repositories\Tests\Examples\TestManagerRepo.cs`

```csharp
using Godot;
using inFras.Bases;
using TO.Domains.Models.Repositories.Abstractions.Test.Examples;
using TO.Nodes.Abstractions.Tests.Examples;

namespace inFras.Tests.Examples;

public class TestManagerRepo : SingletonNodeRepo<ITestManager>, ITestManagerRepo
{
    protected override void Init()
    {
        base.Init();
        GD.Print("TestManagerRepo Init");
    }
}
```

**关键特性**:
- 继承自 `SingletonNodeRepo<ITestManager>`
- 实现对应的仓储接口 `ITestManagerRepo`
- 重写 `Init()` 方法进行自定义初始化
- 单例模式管理

## 🔧 自动注册规则

### NodeRegister - 单例节点注册器

**文件位置**: `d:\GodotProjects\demo\TO.Domains.Models.Repositories.Abstractions\Nodes\NodeRegister.cs`

```csharp
using TO.Domains.Models.Repositories.Abstractions.Core.AudioSystem;
using TO.Domains.Models.Repositories.Abstractions.Core.SceneSystem;
using TO.Domains.Models.Repositories.Abstractions.Core.SerializationSystem;
using TO.Domains.Models.Repositories.Abstractions.Core.UISystem;
using TO.Domains.Models.Repositories.Abstractions.Test.Examples;
using TO.GodotNodes.Abstractions;
using TO.Nodes.Abstractions.Nodes.Singletons;
using TO.Nodes.Abstractions.Tests.Examples;

namespace TO.Domains.Models.Repositories.Abstractions.Nodes;

public class NodeRegister(
    ITestManagerRepo testManagerRepo,
    IUIManagerRepo uiManagerRepo, 
    IAudioManagerRepo audioManagerRepo, 
    ISaveManagerRepo saveManagerRepo,
    ISceneManagerRepo sceneManagerRepo)
{
    public bool Register<T>(T node) where T : INode
    {
        return node switch
        {
            // 单例管理器注册
            ITestManager testManager => testManagerRepo.Register(testManager),
            IUIManager uiManager => uiManagerRepo.Register(uiManager),
            IAudioManager audioManager => audioManagerRepo.Register(audioManager),
            ISaveManager saveManager => saveManagerRepo.Register(saveManager),
            ISceneManager sceneManager => sceneManagerRepo.Register(sceneManager),
            _ => throw new ArgumentException($"暂不支持的单例节点：{typeof(T).Name}")
        };
    }
}
```

**核心功能**:
- **统一注册入口**: 为所有单例管理器节点提供统一的注册接口
- **类型安全**: 通过泛型和模式匹配确保类型安全
- **依赖注入**: 通过构造函数注入所有需要的仓储接口
- **错误处理**: 对不支持的节点类型抛出明确的异常信息

**使用场景**:
- 当单例管理器节点（如 UIManager、AudioManager 等）需要注册到系统时
- 在 `Contexts.Instance.RegisterNode<T>()` 内部被调用
- 确保所有单例节点都能正确注册到对应的仓储中

**扩展步骤**:
1. 在构造函数中添加新的仓储接口参数
2. 在 `Register` 方法的 switch 表达式中添加新的 case 分支
3. 确保新的仓储接口和实现已在 DI 容器中注册

### NodeModule - 节点服务自动注册

**文件位置**: `d:\GodotProjects\demo\TO.Contexts\NodeModule.cs`

```csharp
using System.Reflection;
using Autofac;
using Module = Autofac.Module;

namespace Contexts;

public class NodeModule: Module
{
    protected override void Load(ContainerBuilder builder)
    {
        var appServicesAssembly = Assembly.Load("TO.Apps.Services");
        var repoAssembly = Assembly.Load("TO.Infras.Repositories");
        var servicesTypes = appServicesAssembly.GetTypes()
            .Where(t => t.Name.StartsWith("Node"));

        foreach (var commandType in servicesTypes)
        {
            var repoTypeName = commandType.Name.Replace("Service", "Repo");
            var repoType = repoAssembly.GetTypes().FirstOrDefault(t => 
                t.Name == repoTypeName
            );
            if (repoType != null)
            {
                builder.RegisterType(commandType)
                    .AsSelf()
                    .InstancePerMatchingLifetimeScope(repoType);
            }
        }
    }
}
```

**注册规则**:
1. **命名约定**: 服务类名必须以 `Node` 开头
2. **配对规则**: `NodeXxxService` 对应 `NodeXxxRepo`
3. **生命周期**: 使用 `InstancePerMatchingLifetimeScope` 与对应仓储绑定
4. **程序集扫描**: 自动扫描 `TO.Apps.Services` 和 `TO.Infras.Repositories` 程序集

### SingleModule - 单例服务自动注册

**文件位置**: `d:\GodotProjects\demo\TO.Contexts\SingleModule.cs`

**注册规则**:
1. **应用服务**: 不以 `Node` 开头的类型
2. **领域服务**: 以 `Service` 结尾且不以 `Node` 开头的类型
3. **仓储服务**: 不以 `Node`、`Base`、`Singleton` 开头的类型
4. **接口匹配**: 自动匹配 `XxxService` 与 `IXxxService` 接口
5. **生命周期**: 所有服务注册为 `SingleInstance`

## 📝 命名规范总结

### 表示层 (Scripts/Tests/Examples)
- **节点类**: `TestNode`, `TestManager`
- **接口**: `ITestNode`, `ITestManager`
- **特性**: 使用 `[GlobalClass]` 标记可在编辑器中使用的类

### 应用层 (TO.Apps.Services)
- **节点服务**: `NodeTestNodeService` (以 `Node` 开头)
- **普通服务**: `XxxService` (不以 `Node` 开头)

### 基础设施层 (TO.Infras.Repositories)
- **节点仓储**: `NodeTestNodeRepo` (对应节点服务)
- **单例仓储**: `TestManagerRepo` (对应单例管理器)
- **普通仓储**: `XxxRepo` (不以特殊前缀开头)

### 领域层接口 (TO.Domains.Models.Repositories.Abstractions)
- **节点仓储接口**: `INodeTestNodeRepo`
- **单例仓储接口**: `ITestManagerRepo`
- **节点接口**: `ITestNode`, `ITestManager`

## 🚀 使用指南

### 创建新的节点服务

1. **创建节点接口** (TO.Nodes.Abstractions)
   ```csharp
   public interface IMyNode : INode
   {
       // 节点特定方法
   }
   ```

2. **创建表示层节点** (Scripts)
   ```csharp
   [GlobalClass]
   public partial class MyNode : Node, IMyNode
   {
       public ILifetimeScope? NodeScope { get; set; }
       
       public override void _Ready()
       {
           NodeScope = NodeContexts.Instance.RegisterNode<IMyNode, NodeMyNodeRepo>(this);
       }
   }
   ```

3. **创建应用层服务** (TO.Apps.Services)
   ```csharp
   public class NodeMyNodeService
   {
       // 服务实现
   }
   ```

4. **创建基础设施层仓储** (TO.Infras.Repositories)
   ```csharp
   public class NodeMyNodeRepo : NodeRepo<IMyNode>, INodeMyNodeRepo
   {
       public NodeMyNodeRepo(IMyNode main)
       {
           Node = main;
           Register();
           ContextEvents.TriggerRegisterNode(this, ConfigureNodeScope);
       }
   }
   ```

5. **创建仓储接口** (TO.Domains.Models.Repositories.Abstractions)
   ```csharp
   public interface INodeMyNodeRepo : INodeRepo<IMyNode>
   {
       // 仓储特定方法
   }
   ```

### 创建单例管理器

1. **创建管理器接口**
   ```csharp
   public interface IMyManager : INode
   {
       // 管理器方法
   }
   ```

2. **创建表示层管理器**
   ```csharp
   public partial class MyManager : Node, IMyManager
   {
       public ILifetimeScope? NodeScope { get; set; }
       
       public override void _Ready()
       {
           Contexts.Contexts.Instance.RegisterNode<IMyManager>(this);
       }
   }
   ```

3. **创建单例仓储**
   ```csharp
   public class MyManagerRepo : SingletonNodeRepo<IMyManager>, IMyManagerRepo
   {
       protected override void Init()
       {
           base.Init();
           // 自定义初始化逻辑
       }
   }
   ```

4. **在 NodeRegister 中添加注册逻辑**
   
   **文件位置**: `TO.Domains.Models.Repositories.Abstractions\Nodes\NodeRegister.cs`
   
   ```csharp
   public bool Register<T>(T node) where T : INode
   {
       return node switch
       {
           // 现有的单例注册
           ITestManager testManager => testManagerRepo.Register(testManager),
           IUIManager uiManager => uiManagerRepo.Register(uiManager),
           IAudioManager audioManager => audioManagerRepo.Register(audioManager),
           ISaveManager saveManager => saveManagerRepo.Register(saveManager),
           ISceneManager sceneManager => sceneManagerRepo.Register(sceneManager),
           
           // 新增的管理器注册
           IMyManager myManager => myManagerRepo.Register(myManager),
           
           _ => throw new ArgumentException($"暂不支持的单例节点：{typeof(T).Name}")
       };
   }
   ```
   
   **重要提醒**: 每当创建新的单例管理器时，都必须：
   - 在 `NodeRegister` 构造函数中注入对应的仓储接口
   - 在 `Register` 方法的 switch 表达式中添加对应的 case 分支
   - 确保仓储接口和实现类已正确创建并注册到 DI 容器中

## ⚠️ 注意事项

1. **命名一致性**: 确保服务和仓储的命名遵循约定，以便自动注册生效
2. **接口实现**: 所有节点都必须实现对应的接口
3. **生命周期管理**: 节点服务与仓储的生命周期是绑定的
4. **程序集引用**: 确保相关程序集能够被正确加载
5. **依赖注入**: 通过构造函数注入依赖，避免直接引用其他层的具体实现
6. **⚠️ 非节点服务构造函数**: 应用层中非节点的服务如果构造函数中需要执行逻辑代码，必须在 `TO.Contexts\Contexts.cs` 的构造函数中手动解析该服务（如 `Container.Resolve<IYourService>()`），否则构造函数中的逻辑代码不会被执行。这是因为 DI 容器采用延迟加载策略，只有在显式解析时才会创建实例并执行构造函数
7. **🔴 节点服务层级限制**: 
   - **普通节点**: 只能在应用层(`TO.Apps.Services`)创建服务，领域层中的节点服务不会被自动注册
   - **节点管理器**: 可以同时在领域层和应用层创建服务
   - **违规后果**: 在领域层创建普通节点服务将导致该服务无法被依赖注入容器识别和注册

## 📚 总结

本文档提供了完整的示例代码和自动注册规范，涵盖了从表示层到基础设施层的完整架构。通过遵循这些规范，可以确保：

- **一致性**: 统一的命名和结构规范
- **可维护性**: 清晰的分层架构和依赖关系
- **扩展性**: 基于约定的自动注册机制
- **类型安全**: 强类型的依赖注入和接口约束

在实际开发中，请严格遵循这些规范，以保证代码质量和项目的长期可维护性。

## 🔗 相关文档

- [基于Autofac的倒置节点层实现方案](./基于Autofac的倒置节点层实现方案.md)
- [GodotC#的DDD框架结构](./GodotC#的DDD框架结构.md)
- [场景文件创建规范与依赖注入说明](./场景文件创建规范与依赖注入说明.md)
- [事件总线系统使用规范](./事件总线系统使用规范.md)